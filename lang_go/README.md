# Go言語の勉強
## 基礎知識
- Goで開発をするには、、、
  1. 下記コマンドでプロジェクトフォルダを作成する。  
     ```
     $ mkdir [プロジェクトフォルダ]
     $ cd [プロジェクトフォルダ]
     $ go mod init [アプリケーション名]
     ```
  2. 拡張子が`.go`のファイルを作成する。
  3. 下記コマンドでgoファイルをビルドする。
     ```
     go build [goファイル名]
     ```
  4. 下記コマンドでビルドされた実行ファイルが動作することを確認する。
     ```
     [生成されたexeファイル]
     ```
  5. なお、ビルドと実行を一括で実施する場合は、下記コマンドを使用する。
     ```
     go run [goファイル名]
     ```

## 環境情報
- Goのバージョン: 1.22.0
- 使用するOS: Windows 11
- 使用するエディター: Visual Studio Code
  - プラグイン:
- 使用するCLI: コマンドプロンプト 

## 目次
1. [データ型と変数、定数](#データ型と変数定数)
    1. [データ型](#データ型)
    2. [変数の宣言](#変数の宣言)
    3. [定数の宣言](#定数の宣言)
    4. [特別な定数 `iota`](#特別な定数-iota)
    5. [文字列](#文字列)
    6. [配列とスライス](#配列とスライス)
    7. [マップ](#マップ)
    8. struct（構造体）
    9. interface{}またはany
2. 基本文法
    1. 四則演算
    2. 条件分岐
    3. 繰り返し処理
    4. メソッド
    5. ポインタ
    6. コンストラクタ
    7. インターフェース
    8. 後処理
    9. ゴルーチン
    10. チャネル
    11. 制御構文（select）


## データ型と変数、定数
### データ型
#### 整数型  
|データ型|概要|備考|
|:--:|----|----|
|int8|符号付き8ビット整数型||
|int16|符号付き16ビット整数型||
|int32|符号付き32ビット整数型|int (32ビット環境)、ルーン (rune)ともいう|
int64|符号付き64ビット整数型|int (64ビット環境)ともいう|
|uint8|符号なし8ビット整数型|byteともいう|
|uint16|符号なし16ビット整数型||
|uint32|符号なし32ビット整数型|uint (32ビット環境)ともいう|
|uint64|符号なし64ビット整数型|uint (32ビット環境)ともいう|

#### 浮動小数点型
|データ型|概要|備考|
|:--:|----|----|
|float32|32ビット浮動小数点型||
|float64|64ビット浮動小数点型||

#### その他のデータ型
|データ型|概要|備考|
|:--:|----|----|
|string|文字列型。`"`で囲って宣言する。||
|bool|真偽型。`true` (真) や `false` (偽) を表す。||

### 変数の宣言
変数は下記のように、`var`を用いて宣言する。  
また、変数の宣言と初期値の入力を同時にすることも可能。  
但し、宣言した変数に異なるデータ型の値を入れたり、変数をそもそも使用しなかった場合、コンパイルエラーになるので、注意すること。
```go
// 宣言方法１
var [変数名] [データ型]
[変数名] = [値]

// 宣言方法２
var [変数名] [データ型] = [値]
```
変数の宣言時に、`var`を使用しない方法もある。  
この場合、右辺の値のデータ型が推測できる場合は、明示的にデータ型を宣言する必要はない。
```go
[変数名] := [値]
// 例（x, zはint型、yはfloat64型）
x := 1
y := 2.5
z := 1 + x * 2
```

### 定数の宣言
変数は下記のように、`const`を用いて宣言する。  
宣言で使用できるデータ型は、「真偽型・数値型・複素数型・文字列型」のみである。  
なお、変数と違い、宣言した定数を使用しなくても、コンパイルエラーにはならない。
```go
// 宣言方法
const [定数名] = [値]
```
定数に関しては、データ型を明示する必要はなく、使われ方で自動的にデータ型が決定する。  
その為、下記のように記載してもコンパイルエラーにはならないが、異なるデータ型の変数に対して処理をする場合は、キャストする必要がある。
```go
const x = 100
var num1 int = 10 + x
var num2 float64 = 12.5 + x
var num3 float64 = float64(num1) + num2
```
また、定数は下記のようにすることで、複数個をまとめて宣言することができる。  
一つずつ宣言すると、それぞれの定数に値が入力されるが、  
最初の一つだけ宣言すると、全ての定数に同じ値が入力される。
```go
const (
  a int    = 1
  b int    = 2
  c string = "Japan"
)
fmt.Println(a, b, c) // 1 2 Japan

const (
  d int = 1
  e
  f
)
fmt.Println(d, e, f) // 1 1 1
```

### 特別な定数 `iota`
iotaは値の並びを表現するために使われる特別な定数。  
各定数が一意な値を持つ列挙型を表現するためによく使用される。  
iotaは行が変わるたびに自動的にインクリメントされる。
```go
// 曜日を表す定数のセットを定義する例
const (
  Monday    = iota // 0
  Tuesday   = iota // 1
  Wednesday = iota // 2
  Thursday  = iota // 3
  Friday    = iota // 4
  Saturday  = iota // 5
  Sunday    = iota // 6
)
fmt.Println(Wednesday) // 2

// 曜日を表す定数のセットを定義する例
// 連続して記述する場合、2行目以降は省略可能
const (
  Mon = iota
  Tue
  Wed
  Thu
  Fri
  Sat
  Sun
)
```

### 文字列
Goで文字列を扱う場合、`"`で囲って使用する。  
コンソール出力する場合は、fmtパッケージの`Println`メソッドを使用する。  
文字列同士の結合も可能である。
```go
var str1 string = "Hello "
fmt.Println(str1) // Hello 
var str2 string = str1 + "world!"
fmt.Println(str2) // Hello world!
```
また、文字列はバイト列で構成されているため、添え字でのアクセスが可能である。  
但し、string型で宣言すると、イミュータブルな値になるため、値の書き換えができなくなる。  
書き換える場合は、バイト列に変換してから行う必要がある。
```go
fmt.Printf("%c, %c", str2[0], str2[8]) // H, r

str3 := []byte(str2)
str3[0] = 'h'
str2 = string(str3)
fmt.Println(str2) // hello world!
```
Goで複数行の文字列を扱う場合は、`` ` ``で囲うことで使用できる。
```go
var str4 = `今日の
夕飯は
お寿司でした。
`
fmt.Println(str4)
// 今日の
// 夕飯は
// お寿司でした。
// 
```
### 配列とスライス


### マップ


